<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>å·¥å…·é›†åˆï¼šåŠ å¯† / ç·¨ç¢¼ / æ™‚é–“æˆ³è¨˜</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
  <h2>AES å¯†æ–‡ç”¢ç”Ÿå™¨</h2>
  <label>æ˜æ–‡ï¼š</label><br>
  <input type="text" id="inputText" style="width: 300px;"><br><br>
  <label>é‡‘é‘°ï¼š</label><br>
  <input type="text" id="inputKey" style="width: 300px;"><br><br>
  <button onclick="encrypt()">ğŸ” æ‰‹å‹•åŠ å¯†</button>
  <button onclick="copyCipher()">ğŸ“‹ è¤‡è£½å¯†æ–‡</button>
  <button onclick="downloadCipher()">â¬‡ï¸ ä¸‹è¼‰å¯†æ–‡</button>
  <h3>å¯†æ–‡çµæœï¼š</h3>
  <pre id="result" style="background: #f4f4f4; padding: 1em;"></pre>

  <hr>

  <h2>ğŸ”— å­—ä¸² â†”ï¸ URL Encoding</h2>
  <textarea id="urlInput" placeholder="è¼¸å…¥å­—ä¸²æˆ–URLç·¨ç¢¼" rows="2" cols="60"></textarea><br>
  <button onclick="encodeURL()">â¡ï¸ ç·¨ç¢¼</button>
  <button onclick="decodeURL()">â¬…ï¸ è§£ç¢¼</button>
  <button onclick="copyURL()">ğŸ“‹ è¤‡è£½çµæœ</button>
  <pre id="urlResult" style="background: #eef; padding: 1em;"></pre>

  <hr>

  <h2>ğŸ•’ æ—¥æœŸæ™‚é–“ â†”ï¸ Unix Timestamp</h2>
  <div>
    <label>æ—¥æœŸæ™‚é–“ï¼š</label>
    <input type="datetime-local" id="timestampInput">
    <button onclick="convertToTimestamp()">â¡ï¸ è½‰æˆ Timestamp</button>
  </div>
  <div>
    <label>Timestampï¼š</label>
    <input type="text" id="timestampOutput" style="width:200px">
    <button onclick="convertToDate()">â¬…ï¸ è½‰æˆæ—¥æœŸ</button>
    <button onclick="copyTimestamp()">ğŸ“‹ è¤‡è£½ Timestamp</button>
  </div>
  <pre id="timestampResult" style="background: #efe; padding: 1em;"></pre>

  <hr>

  <h2>ğŸ”‘ è®€å– URL åƒæ•¸ä¸¦åŠ å¯†</h2>
  <pre id="paramsResult"></pre>

  <script>
    // URL åƒæ•¸è®€å–
    function getURLParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const sourceString = urlParams.get('sourceString');
      const aesKey = urlParams.get('AesKey');
      
      if (sourceString && aesKey) {
        document.getElementById("inputText").value = sourceString;
        document.getElementById("inputKey").value = aesKey;
        encrypt(); // ç«‹åˆ»åŠ å¯†ä¸¦é¡¯ç¤ºå¯†æ–‡
        document.getElementById("paramsResult").innerText = `å·²è®€å– URL åƒæ•¸ï¼š\nsourceString: ${sourceString}\nAesKey: ${aesKey}`;
      } else {
        document.getElementById("paramsResult").innerText = "æœªæ‰¾åˆ°æœ‰æ•ˆçš„ URL åƒæ•¸ã€‚";
      }
    }

    // åˆæ¬¡é é¢è¼‰å…¥æ™‚ï¼Œè®€å– URL åƒæ•¸
    window.onload = getURLParams;

    function getGUID(length) {
      const chars = 'abcdef0123456789';
      let result = '';
      for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function md5ToBytes(input) {
      const hex = CryptoJS.MD5(input).toString();
      const bytes = new Uint8Array(16);
      for (let i = 0; i < 16; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }

    async function aesEncryptBase64(sourceStr, cryptoKey) {
      const enc = new TextEncoder();
      const keyBuffer = await crypto.subtle.digest('SHA-256', enc.encode(cryptoKey));
      const key = await crypto.subtle.importKey('raw', keyBuffer, { name: 'AES-CBC' }, false, ['encrypt']);
      const iv = md5ToBytes(cryptoKey);
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-CBC', iv }, key, enc.encode(sourceStr));
      return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
    }

    async function DoEncrypt(inpSourceStr, aesKey) {
      inpSourceStr = inpSourceStr || '';
      const size = inpSourceStr.length;
      const midIndex = Math.floor(size / 2);
      const sourcePart1 = inpSourceStr.substring(0, midIndex);
      const sourcePart2 = inpSourceStr.substring(midIndex);
      const topGuidLength = (Math.floor(Math.random() * 10) % 10) + 5;
      const saltTopContent = getGUID(topGuidLength);
      const now = new Date();
      const saltMidContent = now.toISOString().replace('T', ' ').substring(0, 19);
      const bottomGuidLength = (Math.floor(Math.random() * 10) % 10) + 5;
      const saltBottomContent = getGUID(bottomGuidLength);
      const saltSource = `<SaltTop='${saltTopContent}'>${sourcePart1}<SaltMid='${saltMidContent}'>${sourcePart2}<SaltBottom='${saltBottomContent}'>`;
      return await aesEncryptBase64(saltSource, aesKey);
    }

    async function encrypt() {
      const text = document.getElementById("inputText").value;
      const key = document.getElementById("inputKey").value;
      if (!text || !key) {
        alert("è«‹è¼¸å…¥æ˜æ–‡èˆ‡é‡‘é‘°");
        return;
      }
      const encrypted = await DoEncrypt(text, key);
      document.getElementById("result").innerText = encrypted;
    }

    function copyCipher() {
      const cipher = document.getElementById("result").innerText;
      navigator.clipboard.writeText(cipher).then(() => alert("å¯†æ–‡å·²è¤‡è£½ï¼"));
    }

    function downloadCipher() {
      const cipher = document.getElementById("result").innerText;
      const blob = new Blob([cipher], { type: 'text/plain' });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "License.txt";
      link.click();
    }

    // URL Encode/Decode
    function encodeURL() {
      const input = document.getElementById("urlInput").value;
      document.getElementById("urlResult").innerText = encodeURIComponent(input);
    }

    function decodeURL() {
      const input = document.getElementById("urlInput").value;
      try {
        document.getElementById("urlResult").innerText = decodeURIComponent(input);
      } catch {
        document.getElementById("urlResult").innerText = "éŒ¯èª¤ï¼šä¸æ˜¯åˆæ³•çš„ URL ç·¨ç¢¼å­—ä¸²ã€‚";
      }
    }

    function copyURL() {
      const content = document.getElementById("urlResult").innerText;
      navigator.clipboard.writeText(content).then(() => alert("URL çµæœå·²è¤‡è£½ï¼"));
    }

    // Timestamp åŠŸèƒ½
    function convertToTimestamp() {
      const input = document.getElementById("timestampInput").value;
      if (!input) {
        alert("è«‹é¸æ“‡æ™‚é–“");
        return;
      }
      const date = new Date(input);
      const ts = (date.getTime() / 1000).toFixed(7);
      document.getElementById("timestampOutput").value = ts;
      document.getElementById("timestampResult").innerText = `Unix Timestampï¼š${ts}`;
    }

    function convertToDate() {
      const tsStr = document.getElementById("timestampOutput").value;
      const ts = parseFloat(tsStr);
      if (isNaN(ts)) {
        alert("è«‹è¼¸å…¥æœ‰æ•ˆçš„ timestamp");
        return;
      }
      const date = new Date(ts * 1000);
      const iso = date.toISOString().slice(0, 16); // yyyy-MM-ddTHH:mm
      document.getElementById("timestampInput").value = iso;
      document.getElementById("timestampResult").innerText = `å°æ‡‰æ™‚é–“ï¼š${iso.replace('T', ' ')}`;
    }

    function copyTimestamp() {
      const val = document.getElementById("timestampOutput").value;
      navigator.clipboard.writeText(val).then(() => alert("Timestamp å·²è¤‡è£½"));
    }
  </script>
</body>
</html>
